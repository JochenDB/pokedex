<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <title>Set Recommendations - De Bietjes Pok√©dex</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
    .sticky-top-bar { position: sticky; top: 0; z-index: 1020; background: rgba(255,255,255,.95); backdrop-filter: blur(6px); }
    .set-card { border-radius: 16px; overflow: hidden; transition: transform 0.2s, box-shadow 0.2s; height: 100%; cursor: pointer; }
    .set-card:hover { transform: translateY(-4px); box-shadow: 0 12px 24px rgba(0,0,0,0.15) !important; }
    .set-header { padding: 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; position: relative; }
    .set-logo-container { height: 50px; margin-bottom: 0.5rem; display: flex; align-items: flex-end; }
    .set-logo { max-width: 150px; max-height: 50px; object-fit: contain; }
    .score-badge { position: absolute; top: 1rem; right: 1rem; background: rgba(255,255,255,0.95); color: #667eea; font-weight: 700; font-size: 1.25rem; padding: 0.4rem 0.8rem; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); text-align: center; }
    .score-badge small { display: block; font-size: 0.6rem; font-weight: 500; opacity: 0.8; }
    .metrics-row { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; }
    .metric-badge { flex: 1; background: #f8f9fa; border-radius: 8px; padding: 0.5rem; text-align: center; }
    .metric-badge .value { font-size: 1.1rem; font-weight: 700; color: #667eea; }
    .metric-badge .label { font-size: 0.65rem; color: #6c757d; }
    .metric-badge.highlight { background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%); }
    .info-icon { cursor: help; opacity: 0.7; }
    .info-icon:hover { opacity: 1; }
    .set-body { padding: 1.5rem; }
    .missing-count { font-size: 2rem; font-weight: 700; color: #667eea; margin-bottom: 0.5rem; }
    .rarity-bar { height: 8px; border-radius: 4px; margin-bottom: 0.5rem; }
    .rarity-item { display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0; font-size: 0.875rem; }
    .rarity-label { display: flex; align-items: center; gap: 0.5rem; }
    .rarity-dot { width: 12px; height: 12px; border-radius: 50%; }
    .stats-card { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border-radius: 16px; padding: 1.5rem; }
    .nav-link-custom { color: #667eea; font-weight: 600; text-decoration: none; padding: 0.5rem 1rem; border-radius: 8px; transition: background 0.2s; }
    .nav-link-custom:hover { background: rgba(102, 126, 234, 0.1); color: #667eea; }
    .pokemon-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 0.5rem; margin-top: 1rem; }
    .pokemon-chip { background: #f8f9fa; border-radius: 8px; padding: 0.5rem; text-align: center; font-size: 0.75rem; border: 2px solid transparent; }
    .pokemon-chip.owned { border-color: #28a745; background: #d4edda; }
    .pokemon-chip.missing { border-color: #dc3545; background: #f8d7da; }
    .filter-btn { margin: 0.25rem; }
    .modal-card-wrapper { border-radius: 12px; overflow: hidden; transition: transform 0.2s, box-shadow 0.2s; background: white; }
    .modal-card-wrapper:hover { transform: translateY(-4px); box-shadow: 0 8px 16px rgba(0,0,0,0.1) !important; cursor: pointer; }
    .modal-card-image { width: 100%; height: auto; display: block; border-radius: 12px 12px 0 0; }
    .modal-card-info { padding: 0.5rem; }
    .modal-card-title { font-weight: 600; font-size: 0.875rem; color: #212529; margin-bottom: 0.25rem; }
    .modal-card-number { font-size: 0.75rem; color: #6c757d; }
    .modal-card-meta { font-size: 0.7rem; color: #adb5bd; margin-top: 0.25rem; }
    .modal-filter-btn { margin: 0.25rem; }
    .modal-card-wrapper.card-owned { opacity: 0.6; position: relative; }
    .modal-card-wrapper.card-owned::after { content: '‚úì'; position: absolute; top: 0.5rem; right: 0.5rem; background: #28a745; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1rem; }
  </style>
</head>

<body class="bg-light">
  <div class="sticky-top-bar border-bottom">
    <div class="container py-3">
      <div class="d-flex flex-wrap gap-3 align-items-center justify-content-between">
        <div>
          <h1 class="h4 mb-0">Set Recommendations</h1>
          <small class="text-muted">Find the best sets to complete your Pok√©dex</small>
        </div>
        <div class="d-flex gap-2 align-items-center">
          <a href="dex.html" class="nav-link-custom">‚Üê Back to Pok√©dex</a>
        </div>
      </div>
    </div>
  </div>

  <div class="container my-4">
    <!-- Summary Stats -->
    <div class="row mb-4">
      <div class="col-md-4 mb-3">
        <div class="stats-card">
          <div class="h2 mb-0" id="totalSets">-</div>
          <small>Total Sets</small>
        </div>
      </div>
      <div class="col-md-4 mb-3">
        <div class="stats-card" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
          <div class="h2 mb-0" id="totalMissing">-</div>
          <small>Missing Pok√©mon, available in these sets</small>
        </div>
      </div>
      <div class="col-md-4 mb-3">
        <div class="stats-card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); cursor: pointer;" id="unavailableCard" data-bs-toggle="modal" data-bs-target="#unavailableModal">
          <div class="h2 mb-0" id="unavailableCount">-</div>
          <small>Unavailable in these sets üîç</small>
        </div>
      </div>
    </div>

    <!-- Sorting & Filters -->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <div class="row align-items-center">
          <div class="col-md-6 mb-2">
            <label class="form-label small text-muted mb-1">Sort By</label>
            <select id="sortBy" class="form-select">
              <option value="pullChance">Best Pull Chance (Relative)</option>
              <option value="density">Highest Missing % (Relative)</option>
              <option value="score">Best Recommendation (Absolute)</option>
              <option value="missing">Most Missing Pok√©mon (Absolute)</option>
              <option value="name">Set Name (A-Z)</option>
              <option value="dateNew">Release Date (Newest First)</option>
              <option value="dateOld">Release Date (Oldest First)</option>
            </select>
          </div>
          <div class="col-md-6 mb-2">
            <label class="form-label small text-muted mb-1">What do the scores mean? <span class="info-icon" data-bs-toggle="collapse" data-bs-target="#metricsHelp">‚ÑπÔ∏è</span></label>
            <div>
              <small class="text-muted">Click on any set to see missing cards</small>
            </div>
          </div>
        </div>
        <div class="collapse" id="metricsHelp">
          <div class="alert alert-info mt-3 mb-0">
            <strong>Understanding the Metrics:</strong>
            <ul class="mb-0 mt-2">
              <li><strong>Pull Chance %</strong> ‚Äî Likelihood that a pulled Pok√©mon will be NEW. Accounts for rarity (Common = easier to pull). <em>Higher = better chance of getting something new!</em></li>
              <li><strong>Missing %</strong> ‚Äî Simple percentage of unique Pok√©mon you still need (ignores rarity). <em>Higher = more of the set is useful.</em></li>
              <li><strong>Abs. Score</strong> ‚Äî Total weighted value of missing Pok√©mon. Larger sets score higher. <em>Use this to compare raw potential.</em></li>
            </ul>
            <hr class="my-2">
            <small><strong>Tip:</strong> Use "Best Pull Chance" to find sets where you're most likely to pull a NEW Pok√©mon!</small>
          </div>
        </div>
      </div>
    </div>

    <!-- Set Cards Modal -->
    <div class="modal fade" id="setCardsModal" tabindex="-1" aria-labelledby="setCardsModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-xl modal-dialog-scrollable">
        <div class="modal-content">
          <div class="modal-header flex-column align-items-start">
            <div class="d-flex w-100 justify-content-between align-items-center mb-2">
              <h5 class="modal-title mb-0" id="setCardsModalLabel">Cards</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="d-flex flex-wrap gap-2">
              <button class="btn btn-sm btn-primary modal-filter-btn" id="filterMissing" data-filter="missing">Missing Only</button>
              <button class="btn btn-sm btn-outline-primary modal-filter-btn" id="filterAllPokemon" data-filter="allPokemon">All Cards</button>
            </div>
          </div>
          <div class="modal-body">
            <div id="setCardsList" class="row g-3">
              <!-- Will be populated with JavaScript -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Unavailable Pok√©mon Modal -->
    <div class="modal fade" id="unavailableModal" tabindex="-1" aria-labelledby="unavailableModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="unavailableModalLabel">Pok√©mon NOT Available in Scarlet & Violet Sets</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p class="text-muted">These Pok√©mon cannot be pulled from any current Scarlet & Violet set:</p>
            <div id="unavailablePokemonList" class="row g-2">
              <!-- Will be populated with JavaScript -->
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Sets Grid -->
    <div id="setsGrid" class="row g-4">
      <div class="col-12 text-center py-5">
        <div class="spinner-border text-primary" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2 text-muted">Loading sets data...</p>
      </div>
    </div>
  </div>

  <script>
  // Rarity weights based on typical pull rates
  const RARITY_WEIGHTS = {
    'Common': 1.0,
    'Uncommon': 0.8,
    'Rare': 0.4,
    'Holo Rare': 0.2,
    'Rare Holo': 0.2,
    'Rare Holo GX': 0.1,
    'Rare Holo LV.X': 0.1,
    'Rare Ultra': 0.05,
    'Rare Secret': 0.03,
    'Rare Rainbow': 0.03,
    'Ultra Rare': 0.05,
    'Illustration Rare': 0.08,
    'Double Rare': 0.06,
    'Special Illustration Rare': 0.04,
    'Hyper Rare': 0.03
  };

  const RARITY_COLORS = {
    'Common': '#6c757d',
    'Uncommon': '#17a2b8',
    'Rare': '#ffc107',
    'Holo Rare': '#fd7e14',
    'Rare Holo': '#fd7e14',
    'Ultra Rare': '#dc3545',
    'Illustration Rare': '#e83e8c',
    'Double Rare': '#d63384',
    'Special Illustration Rare': '#6f42c1',
    'Hyper Rare': '#6610f2'
  };

  let setsData = [];
  let ownedPokemon = new Set();
  let dexMap = {};
  let unavailablePokemonList = [];
  let showDetails = false;
  let currentModalSet = null;
  let currentModalFilter = 'missing';

  function findPokemonMatch(pokemonName, dexMap) {
    // Normalize: lowercase and remove punctuation except spaces and hyphens
    const normalized = pokemonName.toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, ' ').trim();
    
    // Check if any Pok√©mon name from dexMap appears as whole word(s) in the card name
    // Sort by length (longest first) to match more specific names first
    const sortedDexEntries = Object.entries(dexMap).sort((a, b) => b[0].length - a[0].length);
    
    for (const [dexName, dexNum] of sortedDexEntries) {
      // Create regex with word boundaries to match whole words only
      // Replace spaces in dexName with \s+ to match any whitespace
      const pattern = '\\b' + dexName.replace(/\s+/g, '\\s+') + '\\b';
      const regex = new RegExp(pattern, 'i');
      
      if (regex.test(normalized)) {
        return dexNum;
      }
    }
    
    return null;
  }

  async function loadAll() {
    const [setsRes, ownedRes, dexRes] = await Promise.all([
      fetch("sets-data.json"),
      fetch("owned.json"),
      fetch("pokedex-map.json")
    ]);

    setsData = await setsRes.json();
    const ownedJson = await ownedRes.json();
    dexMap = await dexRes.json();

    // Build set of owned Pok√©mon
    const allOwnedProducts = ownedJson.products || [];
    for (const p of allOwnedProducts) {
      const dexNum = findPokemonMatch(p.product_name, dexMap);
      if (dexNum) {
        ownedPokemon.add(dexNum);
      }
    }

    calculateRecommendations();
    renderSets();
  }

  function calculateRecommendations() {
    for (const set of setsData) {
      let missingWeightedScore = 0;
      let totalWeightedScore = 0;
      let missingByRarity = {};
      
      // Track all Pok√©mon and their best (highest weight) variant
      const allPokemonMap = new Map();
      const missingPokemonMap = new Map();

      for (const pokemon of set.pokemon) {
        // Use dex_number directly if available (new format), fallback to fuzzy matching (old format)
        const dexNum = pokemon.dex_number || findPokemonMatch(pokemon.name, dexMap);
        if (!dexNum) continue;

        // Find best variant (highest weight) for this Pok√©mon
        let bestWeight = 0;
        let bestRarity = 'Common';
        for (const card of pokemon.cards) {
          const rarity = card.rarity || 'Common';
          const weight = RARITY_WEIGHTS[rarity] || 0.01;
          if (weight > bestWeight) {
            bestWeight = weight;
            bestRarity = rarity;
          }
        }

        // Track for total weighted score (all Pok√©mon)
        if (!allPokemonMap.has(dexNum) || allPokemonMap.get(dexNum).weight < bestWeight) {
          allPokemonMap.set(dexNum, { weight: bestWeight, rarity: bestRarity });
        }

        // Track missing Pok√©mon separately
        if (!ownedPokemon.has(dexNum)) {
          if (!missingPokemonMap.has(dexNum) || missingPokemonMap.get(dexNum).weight < bestWeight) {
            missingPokemonMap.set(dexNum, { weight: bestWeight, rarity: bestRarity });
          }
        }
      }
      
      // Calculate total weighted score for ALL Pok√©mon
      for (const [dexNum, data] of allPokemonMap.entries()) {
        totalWeightedScore += data.weight;
      }
      
      // Calculate missing weighted score and rarity breakdown
      for (const [dexNum, data] of missingPokemonMap.entries()) {
        missingWeightedScore += data.weight;
        missingByRarity[data.rarity] = (missingByRarity[data.rarity] || 0) + 1;
      }

      set.score = missingWeightedScore;
      set.totalWeightedScore = totalWeightedScore;
      set.missingCount = missingPokemonMap.size;
      set.missingByRarity = missingByRarity;
      set.totalPokemon = allPokemonMap.size;
      set.ownedCount = set.totalPokemon - set.missingCount;
      
      // Pull Chance %: What portion of expected pulls will be NEW Pok√©mon?
      set.pullChance = totalWeightedScore > 0 ? (missingWeightedScore / totalWeightedScore) * 100 : 0;
      // Simple missing percentage (without rarity weights)
      set.missingDensity = set.totalPokemon > 0 ? (set.missingCount / set.totalPokemon) * 100 : 0;
    }

    // Update summary stats
    // Calculate unique Pok√©mon across all sets
    const uniquePokemonInSets = new Set();
    const uniqueMissingPokemon = new Set();
    
    for (const set of setsData) {
      for (const pokemon of set.pokemon) {
        // Use dex_number directly if available (new format), fallback to fuzzy matching (old format)
        const dexNum = pokemon.dex_number || findPokemonMatch(pokemon.name, dexMap);
        if (dexNum) {
          uniquePokemonInSets.add(dexNum);
          if (!ownedPokemon.has(dexNum)) {
            uniqueMissingPokemon.add(dexNum);
          }
        }
      }
    }
    
    const totalUniquePokemon = uniquePokemonInSets.size;
    const uniqueMissingCount = uniqueMissingPokemon.size;
    const uniqueOwnedCount = totalUniquePokemon - uniqueMissingCount;
    const completionRate = totalUniquePokemon > 0 ? ((uniqueOwnedCount / totalUniquePokemon) * 100).toFixed(1) : 0;

    // Calculate Pok√©mon NOT in any sets (unavailable to pull) AND not already owned
    const allDexNumbers = new Set(Object.values(dexMap));
    const unavailablePokemon = new Set();
    
    for (const dexNum of allDexNumbers) {
      if (!uniquePokemonInSets.has(dexNum) && !ownedPokemon.has(dexNum)) {
        unavailablePokemon.add(dexNum);
      }
    }
    
    unavailablePokemonList = Array.from(unavailablePokemon)
      .map(dexNum => {
        // Find the name from dexMap
        for (const [name, num] of Object.entries(dexMap)) {
          if (num === dexNum) {
            return { dexNum, name };
          }
        }
        return null;
      })
      .filter(p => p !== null)
      .sort((a, b) => a.dexNum - b.dexNum);
    
    document.getElementById('totalSets').textContent = setsData.length;
    document.getElementById('totalMissing').textContent = uniqueMissingCount;
    document.getElementById('unavailableCount').textContent = unavailablePokemonList.length;
    
    // Populate modal
    populateUnavailableModal();
  }

  function populateUnavailableModal() {
    const listDiv = document.getElementById('unavailablePokemonList');
    listDiv.innerHTML = '';
    
    for (const pokemon of unavailablePokemonList) {
      const col = document.createElement('div');
      col.className = 'col-md-4 col-6';
      
      const chip = document.createElement('div');
      chip.className = 'pokemon-chip';
      chip.style.textAlign = 'left';
      chip.style.background = '#fff3cd';
      chip.style.borderColor = '#ffc107';
      
      const displayName = pokemon.name.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      chip.innerHTML = `<strong>#${pokemon.dexNum}</strong> ${displayName}`;
      
      col.appendChild(chip);
      listDiv.appendChild(col);
    }
  }

  function renderSets() {
    const sortBy = document.getElementById('sortBy').value;
    
    // Sort sets
    const sorted = [...setsData].sort((a, b) => {
      if (sortBy === 'pullChance') return b.pullChance - a.pullChance;
      if (sortBy === 'density') return b.missingDensity - a.missingDensity;
      if (sortBy === 'score') return b.score - a.score;
      if (sortBy === 'missing') return b.missingCount - a.missingCount;
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'dateNew') return new Date(b.release_date) - new Date(a.release_date);
      if (sortBy === 'dateOld') return new Date(a.release_date) - new Date(b.release_date);
      return 0;
    });

    const grid = document.getElementById('setsGrid');
    grid.innerHTML = '';

    for (const set of sorted) {
      const col = document.createElement('div');
      col.className = 'col-md-6 col-lg-4';

      const card = document.createElement('div');
      card.className = 'card set-card shadow-sm';

      // Header
      const header = document.createElement('div');
      header.className = 'set-header';
      
      const scoreBadge = document.createElement('div');
      scoreBadge.className = 'score-badge';
      
      // Dynamic badge based on selected sort
      let badgeValue, badgeLabel, badgeTitle;
      switch (sortBy) {
        case 'pullChance':
          badgeValue = `${set.pullChance.toFixed(1)}%`;
          badgeLabel = 'pull chance';
          badgeTitle = 'Pull Chance: Likelihood that a pulled Pok√©mon will be NEW';
          break;
        case 'density':
          badgeValue = `${set.missingDensity.toFixed(1)}%`;
          badgeLabel = 'missing %';
          badgeTitle = 'Missing %: Percentage of set you still need';
          break;
        case 'score':
          badgeValue = set.score.toFixed(1);
          badgeLabel = 'abs. score';
          badgeTitle = 'Absolute Score: Total weighted value of missing Pok√©mon';
          break;
        case 'missing':
          badgeValue = set.missingCount;
          badgeLabel = 'missing';
          badgeTitle = 'Total missing Pok√©mon in this set';
          break;
        default:
          badgeValue = `${set.pullChance.toFixed(1)}%`;
          badgeLabel = 'pull chance';
          badgeTitle = 'Pull Chance: Likelihood that a pulled Pok√©mon will be NEW';
      }
      scoreBadge.innerHTML = `${badgeValue}<small>${badgeLabel}</small>`;
      scoreBadge.title = badgeTitle;
      
      header.innerHTML = `
        <div class="set-logo-container">
          ${set.logo ? `<img src="${set.logo}" alt="${set.name}" class="set-logo">` : ''}
        </div>
        <h5 class="mb-1">${set.name}</h5>
        <small class="opacity-75">${set.series}</small>
      `;
      header.appendChild(scoreBadge);

      // Body
      const body = document.createElement('div');
      body.className = 'set-body';

      const missingHtml = `
        <div class="metrics-row">
          <div class="metric-badge highlight">
            <div class="value">${set.pullChance.toFixed(1)}%</div>
            <div class="label">Pull Chance</div>
          </div>
          <div class="metric-badge highlight">
            <div class="value">${set.missingDensity.toFixed(1)}%</div>
            <div class="label">Missing %</div>
          </div>
          <div class="metric-badge">
            <div class="value">${set.score.toFixed(1)}</div>
            <div class="label">Abs. Score</div>
          </div>
        </div>
        <div class="missing-count">${set.missingCount} Missing</div>
        <div class="text-muted small mb-3">
          ${set.ownedCount} / ${set.totalPokemon} Pok\u00e9mon owned in set
        </div>
      `;

      // Rarity breakdown
      let rarityHtml = '<div class="mb-3">';
      const sortedRarities = Object.entries(set.missingByRarity).sort((a, b) => b[1] - a[1]);
      for (const [rarity, count] of sortedRarities) {
        const color = RARITY_COLORS[rarity] || '#6c757d';
        rarityHtml += `
          <div class="rarity-item">
            <div class="rarity-label">
              <span class="rarity-dot" style="background: ${color};"></span>
              <span>${rarity}</span>
            </div>
            <span class="badge bg-secondary">${count}</span>
          </div>
        `;
      }
      rarityHtml += '</div>';

      body.innerHTML = missingHtml + rarityHtml;

      card.appendChild(header);
      card.appendChild(body);
      
      // Add click handler to show missing cards modal
      card.addEventListener('click', () => {
        showSetCardsModal(set);
      });
      
      col.appendChild(card);
      grid.appendChild(col);
    }
  }

  function showSetCardsModal(set) {
    currentModalSet = set;
    renderModalCards();
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('setCardsModal'));
    modal.show();
  }
  
  function renderModalCards() {
    if (!currentModalSet) return;
    
    const set = currentModalSet;
    const filter = currentModalFilter;
    
    // Update modal title
    let titleText = set.name;
    if (filter === 'missing') {
      titleText = `Missing Cards - ${set.name}`;
    } else if (filter === 'allPokemon') {
      titleText = `All Cards - ${set.name}`;
    }
    document.getElementById('setCardsModalLabel').textContent = titleText;
    
    // Update button states
    document.querySelectorAll('.modal-filter-btn').forEach(btn => {
      if (btn.dataset.filter === filter) {
        btn.className = 'btn btn-sm btn-primary modal-filter-btn';
      } else {
        btn.className = 'btn btn-sm btn-outline-primary modal-filter-btn';
      }
    });
    
    // Collect cards based on filter
    const cardsToShow = [];
    
    for (const pokemon of set.pokemon) {
      // Use dex_number directly if available (new format), fallback to fuzzy matching (old format)
      const dexNum = pokemon.dex_number || findPokemonMatch(pokemon.name, dexMap);
      if (!dexNum) continue;
      
      const isPokemonOwned = ownedPokemon.has(dexNum);
      
      if (filter === 'missing' && isPokemonOwned) {
        continue; // Skip owned pokemon in missing mode
      }
      
      // Add all card variants for this Pok√©mon
      for (const card of pokemon.cards) {
        cardsToShow.push({
          ...card,
          dexNum: dexNum,
          isPokemonOwned: isPokemonOwned
        });
      }
    }
    
    // Sort by dex number, then by card number
    cardsToShow.sort((a, b) => {
      if (a.dexNum !== b.dexNum) return a.dexNum - b.dexNum;
      return parseInt(a.number) - parseInt(b.number);
    });
    
    // Populate modal with card images
    const listDiv = document.getElementById('setCardsList');
    listDiv.innerHTML = '';
    
    if (cardsToShow.length === 0) {
      listDiv.innerHTML = '<div class="col-12 text-center py-5"><p class="text-muted">No cards to display!</p></div>';
    } else {
      for (const card of cardsToShow) {
        const col = document.createElement('div');
        col.className = 'col-6 col-md-4 col-lg-3';
        
        const wrapper = document.createElement('div');
        wrapper.className = 'modal-card-wrapper shadow-sm';
        
        // Add owned class if showing all cards and pokemon is owned
        if (filter === 'allPokemon' && card.isPokemonOwned) {
          wrapper.classList.add('card-owned');
        }
        
        const img = document.createElement('img');
        img.src = card.image_small;
        img.alt = card.card_name;
        img.className = 'modal-card-image';
        img.loading = 'lazy';
        
        const info = document.createElement('div');
        info.className = 'modal-card-info';
        
        const title = document.createElement('div');
        title.className = 'modal-card-title';
        title.textContent = card.card_name;
        
        const number = document.createElement('div');
        number.className = 'modal-card-number';
        number.textContent = `#${card.dexNum.toString().padStart(3, '0')} ‚Ä¢ ${card.number}`;
        
        const meta = document.createElement('div');
        meta.className = 'modal-card-meta';
        meta.textContent = card.rarity;
        
        info.appendChild(title);
        info.appendChild(number);
        info.appendChild(meta);
        wrapper.appendChild(img);
        wrapper.appendChild(info);
        col.appendChild(wrapper);
        listDiv.appendChild(col);
      }
    }
  }

  // Event listeners
  document.getElementById('sortBy').addEventListener('change', renderSets);
  
  // Modal filter buttons
  document.getElementById('filterMissing').addEventListener('click', () => {
    currentModalFilter = 'missing';
    renderModalCards();
  });
  
  document.getElementById('filterAllPokemon').addEventListener('click', () => {
    currentModalFilter = 'allPokemon';
    renderModalCards();
  });

  // Load data on page load
  loadAll().catch(err => {
    document.getElementById('setsGrid').innerHTML = `
      <div class="col-12 text-center py-5">
        <p class="text-danger">Error loading data: ${err.message}</p>
      </div>
    `;
  });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
