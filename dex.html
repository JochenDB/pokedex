<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <title>PokÃ©dex Progress</title>
  <style>
    .dex-tile { aspect-ratio: 3 / 4; }
    .dex-img { width: 100%; height: 100%; object-fit: cover; display:block; border-radius: 8px 8px 0 0; }
    .dex-missing { background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); display:flex; flex-direction: column; align-items:center; justify-content:center; color:#6c757d; font-size: 0.875rem; text-align: center; padding: 1rem; border-radius: 8px 8px 0 0; }
    .dex-missing .number { font-size: 2rem; font-weight: 700; color: #adb5bd; margin-bottom: 0.5rem; }
    .dex-missing .name { font-weight: 600; text-transform: capitalize; }
    .sticky-top-bar { position: sticky; top: 0; z-index: 1020; background: rgba(255,255,255,.95); backdrop-filter: blur(6px); }
    .card-wrapper { border-radius: 12px; overflow: hidden; transition: transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; }
    .card-wrapper:hover { transform: translateY(-4px); box-shadow: 0 8px 16px rgba(0,0,0,0.1) !important; }
    .card-info { background: white; padding: 0.5rem; height: 110px; display: flex; flex-direction: column; }
    .card-title { font-weight: 600; font-size: 0.95rem; color: #212529; margin-bottom: 0.25rem; word-wrap: break-word; line-height: 1.3; max-height: 2.6em; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; }
    .card-set { font-size: 0.75rem; color: #6c757d; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .card-meta { font-size: 0.7rem; color: #adb5bd; margin-top: auto; }
    .lightbox { display: none; position: fixed; z-index: 9999; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); justify-content: center; align-items: center; }
    .lightbox.active { display: flex; }
    .lightbox img { max-width: 90%; max-height: 90vh; object-fit: contain; border-radius: 38px; border: 8px solid white; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
    .lightbox-close { position: absolute; top: 20px; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; cursor: pointer; }
    .lightbox-close:hover { color: #bbb; }
    .dex-img { cursor: pointer; }
  </style>
</head>

<body class="bg-light">
  <div class="sticky-top-bar border-bottom">
    <div class="container py-3">
      <div class="d-flex flex-wrap gap-3 align-items-center justify-content-between">
        <div class="me-auto">
          <div class="d-flex align-items-baseline gap-2">
            <div class="fw-semibold" id="title">PokÃ©dex</div>
            <div class="text-muted small" id="subtitle"></div>
          </div>

          <div class="text-muted small" id="progressText">Loadingâ€¦</div>
          <div class="progress mt-2" style="height: 10px; max-width: 420px;">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
          </div>
        </div>

        <div class="d-flex flex-wrap gap-2">
          <a href="sets.html" class="btn btn-outline-primary">ðŸ“Š Set Recommendations</a>
          <input id="search" class="form-control" style="width: 260px" placeholder="Search PokÃ©mon (e.g., pikachu)" />
          <select id="rarity" class="form-select" style="width: 200px">
            <option value="">All rarities</option>
          </select>
          <div class="form-check form-switch align-self-center">
            <input class="form-check-input" type="checkbox" role="switch" id="ownedOnly">
            <label class="form-check-label" for="ownedOnly">Owned only</label>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="container py-3">
    <div id="grid" class="row g-2"></div>
  </div>

  <div id="lightbox" class="lightbox">
    <span class="lightbox-close">&times;</span>
    <img id="lightboxImg" src="" alt="">
  </div>

<script>
  const DEX_SIZE = 1025;

  // Common TCG prefix/suffix tokens in product_name you likely don't want as part of the PokÃ©mon name.
  const STRIP_TOKENS = new Set(["ex","gx","v","vmax","vstar","sv","delta","lvx","break","vunion"]);
  const STRIP_PREFIXES = new Set(["team","rockets","rocket","ns","n","dark","light","shining","radiant"]);

  function normalizeName(raw) {
    let s = (raw || "").trim().toLowerCase();

    // Collapse whitespace
    s = s.replace(/\s+/g, " ");

    // Remove most punctuation (keep apostrophes and hyphens)
    s = s.replace(/[^\w\s'â€™-]/g, "");

    // Tokenize and drop prefix/suffix tokens
    const parts = s.split(" ").filter(Boolean);
    const filtered = parts.filter(p => !STRIP_TOKENS.has(p) && !STRIP_PREFIXES.has(p));
    return filtered.join(" ");
  }

  function findPokemonMatch(productName, dexMap) {
    // Normalize: lowercase and remove punctuation except spaces and hyphens
    const normalized = productName.toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, ' ').trim();
    
    // Check if any PokÃ©mon name from dexMap appears as whole word(s) in the card name
    // Sort by length (longest first) to match more specific names first
    const sortedDexEntries = Object.entries(dexMap).sort((a, b) => b[0].length - a[0].length);
    
    for (const [dexName, dexNum] of sortedDexEntries) {
      // Create regex with word boundaries to match whole words only
      // Replace spaces in dexName with \s+ to match any whitespace
      const pattern = '\\b' + dexName.replace(/\s+/g, '\\s+') + '\\b';
      const regex = new RegExp(pattern, 'i');
      
      if (regex.test(normalized)) {
        return dexNum;
      }
    }
    
    return null;
  }

  function debounce(fn, ms) {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }

  function openLightbox(src, alt) {
    const lightbox = document.getElementById("lightbox");
    const lightboxImg = document.getElementById("lightboxImg");
    lightboxImg.src = src;
    lightboxImg.alt = alt;
    lightbox.classList.add("active");
  }

  function closeLightbox() {
    const lightbox = document.getElementById("lightbox");
    lightbox.classList.remove("active");
  }

  let dexMap = null;                 // name -> number
  let dexNameByNumber = null;        // number -> name (canonical key from dexMap)
  let ownedByDex = new Map();        // dexNumber -> chosen owned product object
  let allOwnedProducts = [];         // original array (for filter dropdowns etc.)
  let raritySet = new Set();

  function pickPreferred(existing, candidate) {
    // Decide which card to show if multiple map to same PokÃ©mon.
    // Strategy: prefer higher market_price; if missing, keep existing.
    const a = existing, b = candidate;
    const pa = Number(a?.market_price ?? NaN);
    const pb = Number(b?.market_price ?? NaN);

    if (!Number.isFinite(pa) && Number.isFinite(pb)) return b;
    if (Number.isFinite(pa) && !Number.isFinite(pb)) return a;
    if (Number.isFinite(pa) && Number.isFinite(pb)) return (pb > pa) ? b : a;

    return a || b;
  }

  function updateProgress() {
    const ownedCount = ownedByDex.size;
    const pct = Math.round((ownedCount / DEX_SIZE) * 1000) / 10; // 1 decimal
    document.getElementById("progressText").textContent = `${ownedCount}/${DEX_SIZE} (${pct}%)`;
    document.getElementById("progressBar").style.width = `${(ownedCount / DEX_SIZE) * 100}%`;
    document.getElementById("subtitle").textContent = `(${ownedCount} unique PokÃ©mon)`;
  }

  function populateRarityDropdown() {
    const sel = document.getElementById("rarity");
    // Keep first option, then add sorted
    const rarities = Array.from(raritySet).sort((a,b)=>a.localeCompare(b));
    for (const r of rarities) {
      const opt = document.createElement("option");
      opt.value = r;
      opt.textContent = r;
      sel.appendChild(opt);
    }
  }

  function renderGrid() {
    const grid = document.getElementById("grid");
    const q = document.getElementById("search").value.trim().toLowerCase();
    const ownedOnly = document.getElementById("ownedOnly").checked;
    const rarity = document.getElementById("rarity").value;

    grid.innerHTML = "";

    // Filter by name query against canonical dex name
    let numbers = [];
    for (let n = 1; n <= DEX_SIZE; n++) numbers.push(n);

    if (ownedOnly || rarity) {
      numbers = numbers.filter(n => {
        const owned = ownedByDex.get(n);
        if (ownedOnly && !owned) return false;
        if (rarity && (!owned || owned.rarity !== rarity)) return false;
        return true;
      });
    }

    if (q) {
      numbers = numbers.filter(n => {
        const name = dexNameByNumber[n] || "";
        return name.includes(q);
      });
    }

    for (const num of numbers) {
      const name = dexNameByNumber[num] || `pokemon-${num}`;
      const owned = ownedByDex.get(num);

      const col = document.createElement("div");
      col.className = "col-6 col-sm-4 col-md-3 col-lg-2 col-xl-2";

      const card = document.createElement("div");
      card.className = "border card-wrapper bg-white shadow-sm";

      if (owned) {
        const img = document.createElement("img");
        img.className = "dex-img";
        img.loading = "lazy";
        img.alt = owned.product_name?.trim() || name;
        img.src = owned.image_url;
        img.addEventListener("click", () => openLightbox(owned.image_url, owned.product_name?.trim() || name));
        card.appendChild(img);
        
        const info = document.createElement("div");
        info.className = "card-info p-2";
        
        const productName = owned.product_name?.trim() || name;
        const catalogGroup = owned.catalog_group || '';
        const productSubType = owned.product_sub_type || '';
        const cardNumber = owned.card_number || owned.cardNumber || owned.number || '';
        const rarity = owned.rarity || '';
        const finish = owned.finish || '';
        
        info.innerHTML = `
          <div class="card-title" title="${productName}">${productName}</div>
          ${catalogGroup ? `<div class="card-set text-truncate" title="${catalogGroup}">${catalogGroup}</div>` : ''}
          ${productSubType ? `<div class="card-set text-truncate" title="${productSubType}">${productSubType}</div>` : ''}
          <div class="card-meta">
            <div>${rarity}${cardNumber && rarity ? ' â€¢ ' : ''}${cardNumber}</div>
            ${finish ? `<div>${finish}</div>` : ''}
          </div>
        `;
        card.appendChild(info);
      } else {
        const placeholder = document.createElement("div");
        placeholder.className = "dex-missing dex-tile";
        const formattedName = name.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        placeholder.innerHTML = `
          <div class="number">#${num}</div>
          <div class="name">${formattedName}</div>
        `;
        card.appendChild(placeholder);
      }

      col.appendChild(card);
      grid.appendChild(col);
    }
  }

  async function loadAll() {
    const [dexRes, ownedRes] = await Promise.all([
      fetch("pokedex-map.json"),
      fetch("owned.json")
    ]);

    dexMap = await dexRes.json();
    const ownedJson = await ownedRes.json();

    // Set title
    document.getElementById("title").textContent = `De Bietjes PokÃ©dex`;

    // Build number -> name
    dexNameByNumber = {};
    for (const [name, num] of Object.entries(dexMap)) {
      dexNameByNumber[num] = name;
    }

    allOwnedProducts = Array.isArray(ownedJson.products) ? ownedJson.products : [];

    ownedByDex.clear();
    raritySet.clear();

    const unknownNames = [];

    for (const p of allOwnedProducts) {
      if (!p?.is_owned) continue; // defensive; your data has is_owned true for owned
      
      const dexNum = findPokemonMatch(p.product_name, dexMap);
      if (!dexNum) {
        unknownNames.push(p.product_name);
        continue;
      }

      if (p.rarity) raritySet.add(p.rarity);

      const existing = ownedByDex.get(dexNum);
      ownedByDex.set(dexNum, pickPreferred(existing, p));
    }

    if (unknownNames.length) {
      console.warn("Unmatched product_name values (fix normalizeName or add aliases):", unknownNames.slice(0, 50));
      if (unknownNames.length > 50) console.warn(`(+${unknownNames.length - 50} more)`);
    }

    // Debug: log first owned product to see data structure
    if (allOwnedProducts.length > 0) {
      console.log("Sample product data:", allOwnedProducts[0]);
      console.log("Available fields:", Object.keys(allOwnedProducts[0]));
    }

    populateRarityDropdown();
    updateProgress();
    renderGrid();
  }

  document.getElementById("search").addEventListener("input", debounce(renderGrid, 200));
  document.getElementById("ownedOnly").addEventListener("change", renderGrid);
  document.getElementById("rarity").addEventListener("change", renderGrid);

  document.getElementById("lightbox").addEventListener("click", closeLightbox);
  document.querySelector(".lightbox-close").addEventListener("click", closeLightbox);

  loadAll().catch(err => {
    document.getElementById("progressText").textContent = "Failed to load data";
    console.error(err);
  });
</script>
</body>
</html>
